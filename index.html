<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: black;
    overflow: hidden;
  }

  video {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    background: black;
  }

  #recordButton {
    position: fixed;
    bottom: 32px;
    left: 50%;
    transform: translateX(-50%);
    width: 90px;
    height: 90px;
    border-radius: 50%;
    background: #dc2626;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #recordButton::after {
    content: "";
    width: 60px;
    height: 60px;
    background: white;
    border-radius: 50%;
  }

  svg {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%) rotate(-90deg);
    pointer-events: none;
  }
</style>

<video id="camera" autoplay muted playsinline></video>

<svg width="120" height="120">
  <circle cx="60" cy="60" r="52"
    stroke="#ffffff55" stroke-width="6" fill="none" />
  <circle id="progress"
    cx="60" cy="60" r="52"
    stroke="#dc2626" stroke-width="6" fill="none"
    stroke-linecap="round"
    stroke-dasharray="326.7"
    stroke-dashoffset="326.7" />
</svg>

<div id="recordButton"></div>

<script>
(() => {
  const video = document.getElementById("camera");
  const button = document.getElementById("recordButton");
  const ring = document.getElementById("progress");

  const MAX_TIME = 15000;
  const CIRC = 326.7;

  let stream;
  let recorder;
  let chunks = [];
  let timer;
  let startTime;

  async function initCamera() {
    if (stream) return stream;

    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" },
      audio: true
    });

    video.srcObject = stream;
    return stream;
  }

  function updateRing(elapsed) {
    const p = Math.min(elapsed / MAX_TIME, 1);
    ring.style.strokeDashoffset = CIRC * (1 - p);
  }

  async function startRecording() {
    await initCamera();

    chunks = [];
    ring.style.strokeDashoffset = CIRC;
    button.style.pointerEvents = "none";

    recorder = new MediaRecorder(stream);
    recorder.ondataavailable = e => e.data.size && chunks.push(e.data);

    recorder.onstop = async () => {
      clearInterval(timer);

      const blob = new Blob(chunks, { type: recorder.mimeType });
      const file = new File([blob], "video-15s", { type: blob.type });

      if (navigator.canShare && navigator.canShare({ files: [file] })) {
        try {
          await navigator.share({
            title: "My video",
            files: [file]
          });
        } catch (err) {
          console.warn("Share cancelled or failed", err);
        }
      } else {
        alert("Sharing is not supported on this device.");
      }

      button.style.pointerEvents = "auto";
      ring.style.strokeDashoffset = CIRC;
    };

    recorder.start();
    startTime = Date.now();

    timer = setInterval(() => {
      updateRing(Date.now() - startTime);
    }, 50);

    setTimeout(() => recorder.stop(), MAX_TIME);
  }

  button.addEventListener("click", startRecording);
})();
</script>
